<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="start" title="Site Top" href="../index_j.html">
<link rel="up" title="Tech Notes" href="../cc.html">
<link rel="stylesheet" href="docs.css" type="text/css" media="screen" title="ELM Default">
<title>FATファイル・システムのしくみと操作法</title>
</head>

<body>
<h1>FATファイル・システムのしくみと操作法</h1>
<hr class="hds">

<p><em>このドキュメントは、英語の苦手な方けに<a href="http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx">FAT32ファイルシステム仕様書</a>(以下FAT仕様書)を読み解くためのガイドとして書かれています。オリジナルの内容に沿った記述になっていますが、一部省略されていたりオリジナルには無い解説が多く加えられていたりします。実際のDOS/Windowsの動作がFAT仕様書と異なる場合は、実際の動作に基づいて説明しています。また、このドキュメントの内容には意図しない(または意図した)誤りが混入している可能性があります。実際にFATファイル・システムをインプリメントする際は、必ず一次資料の情報および標準システムの動作を確認しながら行うこと。</em></p>

<h3>もくじ</h3>
<ol>
<li><a href="#first">はじめに</a></li>
<li><a href="#notes">FATファイル・システムの基本</a></li>
<li><a href="#legend">ドキュメント中の表記について</a></li>
<li><a href="#bpb">ブート・セクタとBPB</a></li>
<li><a href="#fat_strucut">FATデータ構造体</a></li>
<li><a href="#fat_determination">FATタイプの決定</a></li>
<li><a href="#fat_access">FATエントリへのアクセス</a></li>
<li><a href="#file_cluster">ファイルとクラスタの結びつけ</a></li>
<li><a href="#fsinfo">FAT32のFSInfo構造体とバックアップ・ブート・セクタ</a></li>
<li><a href="#fat_struct">FATディレクトリ構造体</a></li>
<li><a href="#fat_dir">ディレクトリの操作</a></li>
<li><a href="#time_fmt">日付・時刻フィールドのフォーマット</a></li>
<li><a href="#lfn">長いファイル名</a></li>
<li><a href="#name_space">名前の範囲とコード・ページ</a></li>
<li><a href="#name_matching">LFNとSFNのマッチング</a></li>
<li><a href="#name_conversion">SFNの生成と添字の付加</a></li>
<li><a href="#lfn_elimination">LFNエントリの抑止</a></li>
<li><a href="#lfn_comp">システム間の互換性</a></li>
<li><a href="#partition">ストレージ(物理ドライブ)の区画分け</a></li>
</ol>

<h3 id="first">はじめに</h3>
<p><em>ファイル・システム</em>とは、狭義にはストレージ(補助記憶)上のデータを管理するためのシステム全体のことを指しますが、このドキュメントでは特にFATファイル・システムにおけるストレージ上のデータ・フォーマットを指し、これについて解説していきます。</p>
<p>FAT(File Allocation Table)ファイル・システムは1980年前後に端を発する、MS-DOSでサポートされたファイル・システムです。当初、500Kバイト以下のフロッピー・ディスクに適したシンプルなファイル・システムとして開発されました。その後、より大容量のストレージをサポートするため拡張されてきました。現在は、3つのFATサブ・タイプ(<em>FAT12,FAT16,FAT32</em>)があります。これらの基本的な違いは FAT上のエントリ(配列要素)のサイズで、それぞれの名前に示されるように 12/16/32ビットになります。これらは順に開発され、それぞれ完全に下位互換が保たれています(FAT16対応システムは必ずFAT12も包含し、FAT32対応システムは必ずFAT12/16も包含する)。</p>

<h3 id="notes">FATファイル・システムの基本</h3>
<h4>FATボリューム</h4>
<p>ある一つの完結したFATファイル・システムを<em>論理ボリューム</em>(または論理ドライブ)と呼びます。FATの論理ボリュームは 3または 4つの領域で構成され、各領域は1個または複数のセクタで構成されます。それぞれの領域はボリューム上に次の順に配置されます。</p>
<ol>
<li>予約領域 (ボリュームの管理データ)</li>
<li>FAT領域 (データ領域の割り当て表)</li>
<li>ルート・ディレクトリ領域 (FAT32ボリュームでは存在しない)</li>
<li>データ領域 (ファイルやディレクトリの内容が格納される)</li>
</ol>
<h4>データ形式</h4>
<p>FATファイル・システムは、最初は x86プロセッサを搭載する IBM PC向けに開発されてきました。これの重要な点は、ストレージ上において FATファイル・システムのデータは、全て<em>リトル・エンディアン</em>でストアされることです。もし、対象プラットフォームのアーキテクチャがビッグ・エンディアンのときは、ストレージ上の BPB/FAT/ディレクトリ構造体にアクセスする際にエンディアン変換が必要になります。また、16/32ビットのデータ・フィールドは、そのワード境界にアライメントしているとは限りません。対象 CPUがリトル・エンディアンであっても、非アライメントのワード・アクセスが正しく行えない場合は、やはりバイト単位でアクセスする必要があります。</p>
<p>以上のような理由から、FATボリューム上のデータを typedef struct で定義して構造体メンバとしてアクセスする方法は、パッキング・オプションの環境依存問題も加わりきわめてポータビリティの悪いコードになります。FATボリュームを単純なバイト配列としバイト単位でアクセスする方法は、若干の可読性の低下と引き替えに最良のポータビリティが得られます。</p>

<h3 id="legend">ドキュメント中の表記について</h3>
<p>"0x"で始まる数値は16進数とし、それ以外の数値は10進数とします。</p>
<p>各単位の接頭辞"K"は2の10乗(=1024)とします。同様に"M"は2の20乗(=1048576)、"G"は2の30乗(=1073741824)、"T"は2の40乗とします。</p>
<p>このドキュメントに含まれるプログラム・コードの断片は C言語を想定して書かれていますが、文法には厳密ではありません。</p>
<p>プログラム・コードの断片には、32ビット値と 16ビット値が適当に混在しています。プログラマは型変換によるデータの欠落を認識しそれを避ける方法を知っていることとします。また、全てのデータ型は<em>符号無し</em>とします。符号付きで計算すると意図しない結果になることがあるので行ってはいけません。</p>

<h3 id="bpb">ブート・セクタとBPB</h3>
<p><em>セクタ</em>とはストレージを読み書きする際の最小単位で、一般的に 512/1024/2048バイトのセクタ・サイズが用いられています。それぞれのセクタは<em>セクタ番号</em>で識別され、ストレージの先頭を 0として順に割り振られます。このドキュメントでは、単に「セクタ番号」と言った場合は、ボリュームの先頭セクタを 0とした相対的な番号とします。ストレージ先頭からの絶対的な位置を示す場合は、「物理セクタ番号」と表記します。</p>
<p>FATボリュームで最も重要なデータ構造体は、<em>BPB</em>(BIOS Parameter Block)で、その FATボリュームに関するパラメータが記録されます。BPBは<em>ブート・セクタ</em>に配置されます。このセクタはよく<em>PBR</em>(Private Boot Record)や<em>VBR</em>(Volume Boot Record)などと呼ばれていますが、重要なのは単純にそれが<em>予約領域の先頭セクタ</em>(つまりボリュームの先頭セクタ)であるということです。</p>
<p>BPBは FATファイル・システムの機能追加のたびに拡張されてきました。最初に起きた混乱は BPBの新設によるものです。MS-DOS 1.xでは、ブート・セクタに BPBが存在しませんでした。この最初のバージョンの FATファイル・システムでは、2つのフォーマット(片面および両面360Kバイトの 5.25インチフロッピー・ディスク)しか存在せず、どちらのタイプか決定するのは、ブート・セクタ直後から始まるFATの先頭バイト(FAT[0]の下位8ビット)の値を調べることで行われていました。</p>
<p>この手のメディア決定方法は、MS-DOS 2.xで BPBをブート・セクタに置くことにより取って代わられ、FATの先頭バイトを見る方法はサポートされなくなりました。現在は全てのFATボリュームは、ブート・セクタに BPBを置かなければなりません。</p>
<p>BPBは FATボリュームの認識に関して 2度目の混乱(どれが正しいパラメータなのか?)をもたらしました。MS-DOS 2.xで定義された BPBでは、65536セクタ(セクタ・サイズ 512バイトで 32Mバイト)未満のボリュームにしか対応できませんでした。この制限は、ボリュームの総セクタ数を示すフィールドが 16ビットであったことによります。この制限は、MS-DOS 3.xで BPBを拡張して、32ビットのフィールドを追加することで対処されました。</p>
<p>次の BPBの変更は、FAT32ファイル・システムが現れた Windows 95 OSR2です。当時 FAT16では最大クラスタ数と最大クラスタ・サイズによるボリューム・サイズの制限(2Gバイト)が問題になっていました。FAT32のサポートで、2Gバイトを越えるボリューム・サイズを実現しています。FAT32は仕様上は最大 8Tバイト(512バイト/セクタでは 2Tバイト)まで対応しますが、32Gバイトを超えるボリュームでは FAT以外のファイル・システム(NTFSやexFATなど)の使用が推奨されています。</p>
<p>次の表に、ブート・セクタのデータ・フィールドを示します。表に示す<em>BPB_</em>で始まる名前のフィールドは、BPBの一部です。<em>BS_</em>で始まる名前のフィールドは BPBとは関係なく、単にブート・セクタを構成するフィールドに過ぎません。</p>
<p>FAT32ボリュームの BPBは、BPB先頭から<tt>BPB_TotSec32</tt>フィールドまで FAT12/FAT16ボリュームと共通で、それ以降は FATタイプが FAT32か FAT12/FAT16かで異なります。36バイト目以降のフィールドはどちらか一方のフィールドのみ存在することになります。FATタイプの決定方法については後に解説。</p>

<table class="lst4" id="bpb_fat">
<caption>FAT12/16/32共通フィールド(オフセット0～35)</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>BS_jmpBoot</td><td>0</td><td>3</td>
<td>ブート・ストラップ・コードへのジャンプ命令(x86命令)。このフィールドには次の 2つのフォーマットがあり、前者が一般的。<br>
<tt>0xEB, 0x??, 0x90</tt> (ショート・ジャンプ+NOP)<br>
<tt>0xE9, 0x??, 0x??</tt> (ニア・ジャンプ)<br>
??はジャンプ先により異なる任意の値。これらから外れたフォーマットの場合、そのボリュームは Windowsで認識されない。</td>
</tr>
<tr><td>BS_OEMName</td><td>3</td><td>8</td>
<td><tt>"MSWIN4.1"</tt>が推奨される。ほかに<tt>"MSDOS5.0"</tt>などがよく使われる。このフィールドに関しては、多くの誤解がある。これは単なる名前である。マイクロソフトのOSはこのフィールドに何ら注意を払わないが、いくつかの FATドライバは何らかの参照を行う。この文字列が推奨されるのは、それが互換性問題を最小にする設定であることが理由である。何か違う値を設定しても良いが、いくつかの FATドライバはそのボリュームを認識できないかも知れない。このフィールドは、たいていはそのボリュームを作成したシステムを示している。</td>
</tr>
<tr><td>BPB_BytsPerSec</td><td>11</td><td>2</td>
<td>バイト単位のセクタ・サイズ。有効な値は、512, 1024, 2048または 4096である。マイクロソフトのOSはこれらのセクタ・サイズを適切にサポートする。しかし、サポートするセクタ・サイズを 512に限定していても、このフィールドが 512であることをチェックしない FATドライバが多く存在するため、最大限の互換性が要求されるときは 512を使うべきである。ただし、それは単に互換性に関することであるというのを誤解しないこと。この値は、そのボリュームを格納するストレージのセクタ・サイズと同じでなければならない。</td>
</tr>
<tr><td>BPB_SecPerClus</td><td>13</td><td>1</td>
<td>アロケーション・ユニット(割り当て単位)当たりのセクタ数。FATファイル・システムでは、アロケーション・ユニットのことを<em>クラスタ</em>と呼んでいる。これは 1個以上の連続したセクタのブロックのことで、データ領域はこれを単位に管理される。クラスタ当たりのセクタ数は、2の累乗でかつ 1以上の値でなければならない。したがって、使用できる値は、1, 2, 4, 8, ..., 128ということになるが、クラスタ・サイズ(<tt>BPB_BytsPerSec * BPB_SecPerClus</tt>)が 32Kバイトを越す値は使用すべきではない。一部のシステム(例えば Windows98や NT系Windows)ではセクタ・サイズの大きなメディアにおいて 64K/128K/256Kバイトといったクラスタ・サイズを扱えるが、そのようなボリュームでは多くのシステムやディスク・ユーティリティが正しく動作しないかもしれない。</td>
</tr>
<tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td>
<td>予約領域のセクタ数。このフィールドは 0であってはならない(少なくともこの BPBを含むブート・セクタそれ自身が存在する)。FAT12/16ボリュームでは 1以外の値にすべきではない。なぜなら、FAT12/16の予約領域は 1セクタであると決め打ちし、このフィールドをチェックしないFATドライバが多く存在するからである。FAT32ボリュームでは代表的には 32である。マイクロソフトの OSは 1以上の値を適切にサポートする。</td>
</tr>
<tr><td>BPB_NumFATs</td><td>16</td><td>1</td>
<td>FATの数。このフィールドは常に2に設定すべきである。1以上の何らかの値もまた有効ではあるが、多くのソフトウェア・ツールやいくらかの OSの FATドライバは、2以外では正しく動作しないかも知れない。マイクロソフトの FATドライバは 2以外の値も適切にサポートするが、なお 2以外の値は使用しないことが強く推奨される。<br>
このフィールドの標準値が 2であるのは FATデータに冗長性を持たせるためで、もし FAT中の一部のセクタが破損しても二重化された別の FATがあるので、データが失われる危険が少なくなる。メモリ・カードのような非ディスク・ストレージではそのような冗長性は無用な機能なので、2個目の FATのスペースを省くため 1を使っても良いが、いくつかの FATドライバはそのようなボリュームを正しく認識しないかも知れない。</td>
</tr>
<tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td>
<td>FAT12/16ボリュームでは、ルート・ディレクトリに含まれるディレクトリ・エントリ(=32バイト長)の数(=テーブル・サイズ)を示す。このフィールドには、ディレクトリ・テーブルのサイズが 2セクタ境界にアライメントする値、つまり、<tt>BPB_RootEntCnt * 32</tt>が<tt>BPB_BytsPerSec</tt>の偶数倍になる値を設定すべきである。最大の互換性のためには、FAT16では 512に設定すべきである。FAT32ボリュームではこのフィールドは使われず、常に 0でなければならない。</td>
</tr>
<tr><td>BPB_TotSec16</td><td>19</td><td>2</td>
<td>ボリュームの総セクタ数(古い16ビット・フィールド)。この値は、ボリュームの 4つの領域全てを含んだセクタ数である。FAT12/16でボリュームのセクタ数が<tt>0x10000</tt>以上になるときは、このフィールドには無効値(0)が設定され、真の値が<tt>BPB_TotSec32</tt>に設定される。FAT32ボリュームでは、このフィールドは常に無効値でなければならない。</td>
</tr>
<tr><td>BPB_Media</td><td>21</td><td>1</td>
<td>区画分けされた固定ディスク・ドライブでは<tt>0xF8</tt>が標準値である。区画分けされないリムーバブル・メディアでは<tt>0xF0</tt>がしばしば使われる。このフィールドに有効な値は、<tt>0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE</tt>および<tt>0xFF</tt>で、ほかに重要な点はこれと同じ値を FAT[0]の下位 8ビットに置かなければならないということだけである。これは、MS-DOS 1.xでメディア・タイプの設定に遡り、既に使われていない。</td>
</tr>
<tr><td>BPB_FATSz16</td><td>22</td><td>2</td>
<td>1個の FATが占めるセクタ数。このフィールドは FAT12/FAT16ボリュームでのみ使われる。FAT32ボリュームでは必ず無効値(0)でなければならず、代わりに<tt>BPB_FATSz32</tt>が使われる。FAT領域のサイズは、この値 * <tt>BPB_NumFATs</tt>セクタとなる。</td>
</tr>
<tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td>
<td>トラック当たりのセクタ数。このフィールドは、ジオメトリを持つストレージにのみ関係し、IBM PCのディスクBIOS (INT 0x13)で使用される。それ以外では意味がない。</td>
</tr>
<tr><td>BPB_NumHeads</td><td>26</td><td>2</td>
<td>ヘッド数。このフィールドは、ジオメトリを持つストレージにのみ関係し、IBM PCのディスクBIOS (INT 0x13)で使用される。それ以外では意味がない。</td>
</tr>
<tr><td>BPB_HiddSec</td><td>28</td><td>4</td>
<td>ストレージ上でこのボリュームの手前に存在する隠れた物理セクタの数。一般的に INT 0x13でアクセスされるストレージに関するものであり、どのような値が入るかはシステム依存。ボリュームがストレージの先頭から始まる場合(つまりフロッピー・ディスクなど区画分けされていないもの)では常に 0であるべきである。</td>
</tr>
<tr><td>BPB_TotSec32</td><td>32</td><td>4</td>
<td>ボリュームの総セクタ数(新しい32ビット・フィールド)。この値は、ボリュームの4つの領域全てを含んだセクタ数である。FAT12/16ボリュームで総セクタ数が<tt>0x10000</tt>未満のとき、このフィールドは無効値(0)でなければならなず、真の値は<tt>BPB_TotSec16</tt>に設定される。FAT32ボリュームでは常に有効値が入る。</td>
</tr>
</table>

<p>ここから先のフィールドはそのボリュームが FAT12/16か FAT32かで異なるので、これらを参照する前に FATタイプを決定しなければなりません。また、FAT32ボリュームでは FAT12/16ボリュームに存在しないフィールドもあります。</p>

<table class="lst4" id="bpb_fat16">
<caption>FAT12/16におけるオフセット36以降のフィールド</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>BS_DrvNum</td><td>36</td><td>1</td>
<td>INT 0x13で使われるドライブ番号。このフィールドは、MS-DOSのブートストラップで使われ、フロッピー・ディスクでは<tt>0x00</tt>、固定ディスクでは<tt>0x80</tt>である。実際にはOS依存。</td>
</tr>
<tr><td>BS_Reserved1</td><td>37</td><td>1</td>
<td>予約(WindowsNTで使用)。フォーマットするときは常に 0を設定すべきである。</td>
</tr>
<tr><td>BS_BootSig</td><td>38</td><td>1</td>
<td>拡張ブート・シグネチャ (<tt>0x29</tt>)。これは、続く3つのフィールドが存在することを示す。</td>
</tr>
<tr><td>BS_VolID</td><td>39</td><td>4</td>
<td>ボリューム・シリアル番号。このフィールドと<tt>BS_VolLab</tt>でリムーバブル・ストレージにおけるボリュームの追跡をサポートする。これらの値は FATドライバが不正なメディア交換を検出するのを助ける。この IDは大抵は現在時刻から生成される。</td>
</tr>
<tr><td>BS_VolLab</td><td>43</td><td>11</td>
<td>ボリューム・ラベル。このフィールドは、ルート・ディレクトリに記録される 11バイトのボリューム・ラベルに一致する。FATドライバは、ルート・ディレクトリのボリューム・ラベルを更新したら、この値にも反映させるべきである。ボリューム・ラベルが無い場合は、<tt>"NO NAME "</tt>を設定する。</td>
</tr>
<tr><td>BS_FilSysType</td><td>54</td><td>8</td>
<td><tt>"FAT12&nbsp;&nbsp;&nbsp;"</tt>, <tt>"FAT16&nbsp;&nbsp;&nbsp;"</tt>または<tt>"FAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</tt>のうちいずれかの文字列。多くの人はこの文字列が FATタイプの決定に何らかの関与をしていると思っているが、これは間違いである。このフィールドの名前から、これは BPBの一部ではないことが分かると思う。この文字列は不正確だったり設定されていなかったりすることがしばしばあるので、マイクロソフトの FATドライバは FATタイプの決定にこのフィールドを使わない。一部の FATドライバはこの文字列を参照しているので、互換性問題を避けるためこの文字列はそのボリュームの FATタイプに基づいて設定されるべきである。</td>
</tr>
</table>

<table class="lst4" id="bpb_fat32">
<caption>FAT32におけるオフセット36以降のフィールド</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>BPB_FATSz32</td><td>36</td><td>4</td>
<td>1個の FATが占めるセクタ数。FAT領域のサイズは、この値 * <tt>BPB_NumFATs</tt>セクタとなる。このフィールドに限り FATタイプ決定前に参照する必要があるが、<tt>BPB_FATSz16</tt>が FAT12/16で必ず有効、FAT32で必ず無効になるので問題はない。</td>
</tr>
<tr><td>BPB_ExtFlags</td><td>40</td><td>2</td>
<td>ビット3～0: 0から始まるアクティブなFAT。ビット7が1のとき有効。<br>
ビット6～4: 予約。<br>
ビット7: 0は全てのFATがミラーリングされることを示す。1はビット3～0で示される1個のFATだけがアクティブであることを示す。<br>
ビット15～8: 予約。</td>
</tr>
<tr><td>BPB_FSVer</td><td>42</td><td>2</td>
<td>FAT32ボリュームのバージョン。上位バイトがメジャー・バージョン番号、下位バイトがマイナー・バージョン番号。これは、将来古い FAT32ドライバでマウントされることを考慮することなく FAT32を拡張するためのもの。なお、このドキュメントでは、バージョン 0.0について解説している。<br>
ディスク・ユーティリティは、設計された時点より新しいバージョンの FAT32ボリュームに対しては操作を行うべきでない。また、FAT32ドライバはこのフィールドをチェックし、その値がドライバの書かれた時点より新しいバージョンの場合、そのボリュームをマウントすべきではない。</td>
</tr>
<tr><td>BPB_RootClus</td><td>44</td><td>4</td>
<td>ルート・ディレクトリの先頭クラスタ番号。大抵は 2(つまり先頭クラスタ)が設定されるが、2である必要はない。<br>
ディスク・ユーティリティは、ルート・ディレクトリの位置を変える場合、なるべく先頭で正常なクラスタに置くようにすべきである。これは、もしこのフィールドが誤ってクリアされたとき、ディスク修復ツールが容易にルート・ディレクトリを見つけられるようにするためである。</td>
</tr>
<tr><td>BPB_FSInfo</td><td>48</td><td>2</td>
<td>FAT32ボリュームの予約領域中でFSINFO構造体の置かれるセクタ番号。常に 1(つまりブート・セクタの次)。</td>
</tr>
<tr><td>BPB_BkBootSec</td><td>50</td><td>2</td>
<td>0以外の場合、FAT32ボリュームの予約領域中でブート・セクタのバックアップが置かれるセクタを示す。大抵は 6で、この値以外は推奨されない。</td>
</tr>
<tr><td>BPB_Reserved</td><td>52</td><td>12</td>
<td>将来の拡張のために予約。フォーマット時はゼロを設定すべきである。</td>
</tr>
<tr><td>BS_DrvNum</td><td>64</td><td>1</td>
<td>FAT12/16での説明に同じ。</td>
</tr>
<tr><td>BS_Reserved1</td><td>65</td><td>1</td>
<td>FAT12/16での説明に同じ。</td>
</tr>
<tr><td>BS_BootSig</td><td>66</td><td>1</td>
<td>FAT12/16での説明に同じ。</td>
</tr>
<tr><td>BS_VolID</td><td>67</td><td>4</td>
<td>FAT12/16での説明に同じ。</td>
</tr>
<tr><td>BS_VolLab</td><td>71</td><td>11</td>
<td>FAT12/16での説明に同じ。</td>
</tr>
<tr><td>BS_FilSysType</td><td>82</td><td>8</td>
<td>常に<tt>"FAT32&nbsp;&nbsp;&nbsp;"</tt>。このフィールドは FATタイプの決定には関与しない。</td>
</tr>
</table>

<p>ブート・セクタには、もう一つ重要なことがあります。セクタをバイト列として見たとき、オフセット510, 511はそれぞれ<tt>0x55, 0xAA</tt>でなければなりません。この値が確認できないときは、そのブート・セクタは無効です。多くの FATドキュメントは、「ブート・セクタの最後の 2バイトは<tt>0x55, 0xAA</tt>である」という誤った解説をしています。これは、セクタ・サイズが 512のときは正しいのですが、それ以外の場合は誤ったものとなります。<tt>0x55, 0xAA</tt>は、常にオフセット510, 511に置かれなければなりません(これとセクタの最後の 2バイトの両方に置くのもまたよい)。マイクロソフトのフォーマッタでは、最終の 2バイトには設定しません。</p>
<p>ボリュームのサイズ(<tt>BPB_TotSec16/32</tt>フィールドの値)は、そのボリュームの置かれているコンテナ(ストレージや区画)のサイズより小さくても、全く問題ではありません。アライメントの関係でそのような状態になることは良くあります。</p>
<p>このようなアライメント・ホールは、ストレージ容量の無駄にはなりますが、FATボリューム自体の不正を意味するものではありません。しかし、<tt>BPB_TotSec16/32</tt>の値がそのボリュームのコンテナのサイズより大きい場合は、FATボリュームの破損または不正な設定など深刻な状態と言えます。このようなボリュームを操作した場合、壊滅的なデータ破壊をもたらすことになるので、そのような状態を検出したときは、FATドライバはそのボリュームのマウントを拒否すべきです。</p>

<h3 id="fat_strucut">FATデータ構造体</h3>
<p>次に重要な領域はFATそれ自身です。FATの役目は、ファイルやディレクトリのデータ領域における配置(クラスタ・チェーン)を記録することです。ファイルもディレクトリも FAT上ではその区別はありません。</p>
<p>FATはボリュームのデータ領域をクラスタ番号を使ってマッピングします。FATの各エントリは各クラスタと1:1で対応付けされていて、FAT[2]がデータ領域の先頭クラスタ(クラスタ#2)、FAT[3]がその次(クラスタ#3)…というようになります。FATの先頭 2エントリ(FAT[0], FAT[1])は、データ・クラスタに結びつけられていません。</p>
<p>データ領域の先頭セクタ(=クラスタ#2の先頭セクタ)は、次に示すように BPBフィールドから算出されます。まず最初に、ルート・ディレクトリ領域の占めるセクタ数を算出します。</p>
<pre>RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;</pre>
<p>32というのは、ディレクトリ・エントリ1個のサイズ(バイト)です。当然ですが、セクタ境界に乗らない場合は端数を切り上げて引っかかるセクタを含めます (端数の出る設定は推奨されていませんが)。FAT32ボリュームでは、<tt>BPB_RootEntCnt</tt>は常に 0なので、ルート・ディレクトリ領域も 0になります。</p>
<p>データ領域の先頭は次のように求めます。</p>
<pre>FATSectors = BPB_FATSz16 ? BPB_FATSz16 : BPB_FATSz32;

FirstDataSector = BPB_ResvdSecCnt + (BPB_NumFATs * FATSectors) + RootDirSectors;</pre>
<p>これによりデータ領域の開始セクタ番号が求まります。ストレージが区画分けされている場合などボリュームがストレージの先頭から始まらない場合、セクタ番号は物理セクタ番号と一致しません。</p>
<p>ここで、ある有効なクラスタ#Nが与えられたとすると、そのクラスタの先頭セクタ番号は、次のようになります。</p>
<pre>FirstSectorofCluster = ((N - 2) * BPB_SecPerClus) + FirstDataSector;</pre>

<h3 id="fat_determination">FATタイプの決定</h3>
<p>これについては、どのように行うのが正しいのか相当な混乱があり、大小様々なエラーをもたらしています。実際のところ、FATタイプの決定は次に定義されるようにきわめてシンプルなロジックで行われます。</p>
<p><em>FATタイプ(FAT12/16/32)は、ボリューム上のクラスタ数によってのみ決定され、それ以外の手段は「無い」。</em></p>
<p>では、そのクラスタ数はどのように算出されるのか解説します。これは簡単に言うと、データ領域に存在できるクラスタの数、つまりデータ領域のサイズをクラスタ・サイズで割った値となります。この計算は、全てBPBフィールドの数値を使って行われます。使用する値は全タイプ共通フィールドのものだけなので、タイプ別フィールドを参照する前に FATタイプを決定できます。まず、次に示すようにルート・ディレクトリ領域のセクタ数を求めます。</p>
<pre>RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;</pre>
<p>FAT32ボリュームでは<tt>BPB_RootEntCnt</tt>が常に 0なので<tt>RootDirSectors</tt>も 0になり、ルート・ディレクトリ領域はありません。次にFAT領域のサイズを求め、これらを使ってデータ領域のセクタ数を求めます。これは次に示すように算出します。</p>
<pre>TotalSect = BPB_TotSec16 ? BPB_TotSec16 : BPB_TotSec32;

FATSectors = (BPB_FATSz16 ? BPB_FATSz16 : BPB_FATSz32) * BPB_NumFATs;

DataSectors = TotalSect - BPB_ResvdSecCnt - FATSectors - RootDirSectors;</pre>
<p>つまり、総セクタ数から予約領域、FAT領域、ルート・ディレクトリ領域を引いた残りがデータ領域のセクタ数です。あとは、</p>
<pre>CountofClusters = DataSectors / BPB_SecPerClus;</pre>
<p>としてクラスタ数が求まります。もし端数が出たら、切り捨てます。クラスタ数は、正確にはクラスタ#2から始まるデータ・クラスタの数です。したがって、「クラスタ数 N」のボリュームにおいて、有効な「最大クラスタ番号は N + 1」となります。これで FATタイプを決定できます。これは次のように行います。</p>
<ul>
<li>クラスタ数<em>4085以下</em>のボリュームは<em>FAT12</em>である。</li>
<li>クラスタ数<em>4086以上、65525以下</em>のボリュームは<em>FAT16</em>である。</li>
<li>クラスタ数<em>65526以上</em>のボリュームは<em>FAT32</em>である。</li>
</ul>
<p>これが FATタイプ決定の唯一の手段です。FAT12ボリュームが<tt>4085</tt>を超えるクラスタを持つことはありませんし、FAT16ボリュームが<tt>4086</tt>クラスタ未満だったり、<tt>65525</tt>クラスタを超えたりすることもありません。もしもこのルールを破った不正なFATボリュームの作成を試みても、正しく設計されたFATドライバは意図したものとは異なる FATタイプと認識し、結果としてそれを扱うことができません。</p>
<p>しかし、この境界値は明確に決まっているわけではありません。クラスタ番号の取り得る値からすると上記のようになりますが、実際に出回っている情報やFATドライバではその多くにバラツキ(1,2,8,10または16クラスタ)があります。たとえば、FAT12の最大クラスタ数一つ取っても、FAT仕様書では 4084としている一方、Windowsの動作では 4086となっています。基準となるべきFAT仕様書やシステムからしてこのような状態なので、存在する全ての FATコードにおいて最大限の互換性を確保するため、フォーマットの際は境界値近辺のクラスタ数のボリュームの作成は避けることが推奨されます。FAT仕様書では境界値から 16は離したクラスタ数に設定すべきとしています。</p>
<p>また、このルールを知らずに書かれた FATドライバは、クラスタ数ではなく<tt>BS_FilSysType</tt>フィールドの文字列で FATタイプを決定しているものが多いようです。そのような FATドライバの救済のためにも、<tt>BS_FilSysType</tt>には実際の FATタイプに矛盾しない文字列の設定が推奨されています。</p>
<p>FATタイプがクラスタ数で決まるということは、ボリュームのサイズによって成り得る FATタイプも決まってくるということが分かります。例えば、クラスタ・サイズを512～32Kバイトとした場合、</p>
<ul>
<li>32Mバイト以下のボリュームは、FAT32には成り得ない。</li>
<li>128Mバイト以上のボリュームは、FAT12には成り得ない。</li>
<li>2Mバイト以下や 2Gバイト以上のボリュームは、FAT16には成り得ない。</li>
</ul>
<p>と言うことができます(境界は概値)。特に最後の項目は、FAT32登場の背景としてまだ記憶に新しいことです。</p>

<h3 id="fat_access">FATエントリへのアクセス</h3>
<p>FATに関連してもう一つ重要な点は、FATにアクセスする手順です。まず、クラスタ#Nのエントリは FAT中のどこに置かれるのか知る必要があります。FAT16/32の場合これははきわめて単純で、FATは一般的な 16/32ビット整数の配列そのものです。メモリ上の配列と違う点は、各要素は連続した領域ではなく、FAT領域の先頭セクタから連続した複数のセクタにまたがっているということです。そのクラスタ#Nの FATエントリ(FAT[N])がどのセクタのどのバイト位置かは、次の計算で求められます。</p>
<pre>FAT16エントリ位置:
    ThisFATSecNum = BPB_ResvdSecCnt + (N * 2 / BPB_BytsPerSec);

    ThisFATEntOffset = (N * 2) % BPB_BytsPerSec;
</pre>
<pre>FAT32エントリ位置:
    ThisFATSecNum = BPB_ResvdSecCnt + (N * 4 / BPB_BytsPerSec);

    ThisFATEntOffset = (N * 4) % BPB_BytsPerSec;
</pre>
<p>これにより求められたセクタ番号のバイト位置から 2バイト(FAT16)または 4バイト(FAT32)がそのFATエントリの値です。バイト順はリトル・エンディアンです。FAT16/32ボリュームでは、FATエントリがセクタ境界にまたがることはありません。</p>
<p>FAT32に関してはもう一つ重要な点があります。FAT32ボリュームの FATエントリは 32ビットを占めますが、実際にはその上位4ビットは予約で、下位28ビットだけが有効な値です。予約ビットはフォーマット時に 0を設定され、それ以降は変更してはいけません。このため、FAT32ボリュームの FATエントリから値を取り出すときは、<tt>0x0FFFFFFF</tt>で上位4ビットを ANDマスクする必要があります。また、FATエントリに何らかの値を設定するときは、上位4ビットの値を保存する必要があります。</p>
<pre>
FAT32エントリ取り出し:
    ReadSector(SecBuff, ThisFATSecNum);

    ThisEntryVal = *(uint32*)&amp;SecBuff[ThisFATEntOffset] &amp; 0x0FFFFFFF;
</pre>
<pre>
FAT32エントリ設定:
    ReadSector(SecBuff, ThisFATSecNum);

    tmp = *(uint32*)&amp;SecBuff[ThisFATEntOffset];
    tmp = (tmp &amp; 0xF0000000) | (NewEntryVal &amp; 0x0FFFFFFF);
    *(uint32*)&amp;SecBuff[ThisFATEntOffset] = tmp;

    WriteSector(SecBuff, ThisFATSecNum);
</pre>
<p>FAT12では、FATエントリのサイズが 12ビット(1バイト半)なので、少しだけ複雑になります。クラスタ番号が偶数か奇数かによってバイト中のビット配置が異なるため、それぞれ処理を分ける必要があります。</p>
<pre>FAT12エントリ位置:
    ThisFATSecNum = BPB_ResvdSecCnt + ((N + (N / 2)) / BPB_BytsPerSec);
    ThisFATEntOffset = (N + (N / 2)) % BPB_BytsPerSec;</pre>
<pre>FAT12エントリ取り出し:
    ReadSector(SecBuff, ThisFATSecNum);

    if (N &amp; 1) {    /* 奇数クラスタ番号 */
        ThisEntryVal = (SecBuff[ThisFATEntOffset] &gt;&gt; 4)
                     | ((uint16)SecBuff[ThisFATEntOffset + 1] &lt;&lt; 4);
    } else {        /* 偶数クラスタ番号 */
        ThisEntryVal = SecBuff[ThisFATEntOffset]
                     | ((uint16)(SecBuff[ThisFATEntOffset + 1] &amp; 0x0F) &lt;&lt; 8);
    }
</pre>
<pre>FAT12エントリ設定:
    ReadSector(SecBuff, ThisFATSecNum);

    if (N &amp; 1) {    /* 奇数クラスタ番号 */
        SecBuff[ThisFATEntOffset] = (SecBuff[ThisFATEntOffset] &amp; 0x0F)
                                  | (NewEntryVal &lt;&lt; 4);
        SecBuff[ThisFATEntOffset + 1] = NewEntryVal &gt;&gt; 4;
    } else {        /* 偶数クラスタ番号 */
        SecBuff[ThisFATEntOffset] = NewEntryVal;
        SecBuff[ThisFATEntOffset + 1] = (SecBuff[ThisFATEntOffset + 1] &amp; 0xF0)
                                      | ((NewEntryVal &gt;&gt; 8) &amp; 0x0F);
    }

    WriteSector(SecBuff, ThisFATSecNum);
</pre>
<p>しかし、残念ながらこのコードは正しく動作しません。なぜなら、<tt>ThisFATEntOffset</tt>がセクタの最終バイトになるとき、そのエントリがセクタ境界にまたがるからです。このような例外も適切に処理されるように何らかの工夫をする必要があります。</p>
<p>ここまでのまとめとして、各FATタイプ別のFATエントリの格納状態を次の図に示します。</p>
<p><img src="fat.png" width="720" height="210" alt="FAT entries"></p>

<h3 id="file_cluster">ファイルとデータ・クラスタの結びつけ</h3>
<p>FATボリューム上のファイルやディレクトリは、ディレクトリ・エントリに記録され管理されます。ディレクトリ・エントリにはそのファイルのデータの先頭クラスタ番号が記録され、これが FATへの入り口になります。先頭クラスタ番号は、そのファイルのデータの記録開始クラスタを意味しています。サイズが 0のファイルはデータ・クラスタを持たず、 ディレクトリ・エントリに記録される先頭クラスタ番号は、常に 0になります。クラスタ番号から対応するデータ領域内のクラスタの位置を得るには、次のように計算します。クラスタ番号を Nとすると、</p>
<pre>ThisDataSect = BPB_ResvdSecCnt           /* 予約領域のサイズ */
             + BPB_NumFATs * FATSectors  /* FAT領域のサイズ */
             + RootDirSectors            /* ルート・ディレクトリ領域のサイズ */
             + (N - 2) * BPB_SecPerClus; /* データ領域先頭からの位置 */</pre>
<p>これにより、クラスタ#Nの先頭セクタ番号が求まります。<tt>FATSectors</tt>と<tt>RootDirSectors</tt>は、FATデータ構造体の解説で使用した値です。</p>
<p>ファイル・サイズがクラスタ・サイズより大きい場合は、データは複数のクラスタにまたがって記録されます。そのクラスタに対応する FATエントリの値は、そのクラスタの次のクラスタ番号を示しているので、それを順に辿っていくことにより、ファイル中の任意のデータ・セクタにアクセスすることができます。逆に辿ることはできません。このクラスタ・チェーンの最後のクラスタの FATエントリには、チェーンの終了を示す特別な値(EOCマーク)が入ります。この値はどのクラスタ番号にも一致しない値で、各FATタイプにより次に示す値になります。普通は代表値が使われますが、指定範囲内の値ならどれでも同じです。</p>
<ul>
<li>FAT12: <tt>0xFF8～0xFFF</tt> (代表的には<tt>0xFFF</tt>)</li>
<li>FAT16: <tt>0xFFF8～0xFFFF</tt> (代表的には<tt>0xFFFF</tt>)</li>
<li>FAT32: <tt>0x0FFFFFF8～0x0FFFFFFF</tt> (代表的には<tt>0x0FFFFFFF</tt>)</li>
</ul>
<p>もう一つ特別な値として、不良クラスタ・マークがあります。不良クラスタとは、メディアの不良などによる使用不能セクタを含むクラスタのことです。ボリュームのフォーマット、精査、修復などの際に発見された不良クラスタは FATに記録され、以降そのクラスタがファイルに割り当てられることはありません。不良クラスタ・マークの値は、FAT12では<tt>0xFF7</tt>、FAT16では <tt>0xFFF7</tt>、FAT32では<tt>0x0FFFFFF7</tt>になります。</p>
<p>FAT12/16では有効クラスタ番号がこれらの値に一致することはありません。しかし、FAT32ではクラスタ数の上限が定義されていないので、有効クラスタ番号が不良クラスタ・マークに一致する可能性があります。このようなボリュームはディスク・ユーティリティ等の混乱を招くので、作成を避けるべきです。このため、FAT32のクラスタ数の上限は、実質的に<tt>268435444(約256M)</tt>となります。</p>
<p>一部のシステムでは、インプリメント上の理由からクラスタ数に制限のある場合があります。たとえば、Windows9X/Meでは FATサイズの上限が 16Mバイトになっているので、FAT32では約 4Mクラスタ以上のボリュームが扱えません。</p>
<p>FATエントリの値が 0のクラスタは、未使用でどのファイルにも割り当てられていないことを示しています。0以外の値は、そのクラスタが既に使用中か不良で、新たな割り当ては不可能であることを意味します。未使用クラスタの数はどこにも記録されていないので、ボリュームの空きサイズを得るには、全ての FATエントリを調べなければなりません。FAT32ではクラスタ数が膨大になるので、これを補助する手段(FSInfo)が提供されます。</p>
<p>FATの先頭 2個のエントリ(FAT[0], FAT[1])は、データ・クラスタには結びつけられていません。これらの内容は、フォーマット時に次のように初期化されます。</p>
<ul>
<li>FAT12: <tt>FAT[0] = 0xF??; FAT[1] = 0xFFF;</tt></li>
<li>FAT16: <tt>FAT[0] = 0xFF??; FAT[1] = 0xFFFF;</tt></li>
<li>FAT32: <tt>FAT[0] = 0xFFFFFF??; FAT[1] = 0xFFFFFFFF;</tt></li>
</ul>
<p>??は、BPB_Mediaと同じ値が入ります。FAT[0]の値は特別な機能を持ちませんが、FAT[1]の特定のビットは、FAT16/32において次のような機能を持ちます。</p>
<ul>
<li>シャット・ダウン履歴 (FAT16: bit15、FAT32: bit31): 1:正常、0:不正な中断の発生。</li>
<li>ハード・エラー履歴 (FAT16: bit14、FAT32: bit30): 1:エラーなし、0:ハード・エラー発生。</li>
</ul>
<p>これらのビットは、ボリュームの不正状態の可能性を示すフラグです。これをサポートするOSは、ボリュームの状態をこれらのフラグに記録し、次回起動時にこれらのフラグをチェックしてディスク修復ツールの自動起動を行ったりします。</p>
<p>FAT領域に関してさらに 2つの重要な点があります。一つは、FATの最終セクタは必ずしも全て使われるわけではないということです。FATはセクタの途中で終わっていることがほとんどです。FATドライバは、未使用部分の値に関して何の前提も持ってはいけません。ボリューム作成時は、FAT領域はこの部分を含めてゼロで初期化されます (FAT[0], FAT[1]を除く)。もう一つは、BPBに示される FATサイズ(<tt>BPB_FATSz16/32</tt>)は、FATが実際に必要とするセクタ数より大きい場合もあるということです。つまり、FATの使用域の後に全く使われないセクタが続く場合もあります。これは、データ領域のアライメント調整などの目的で挿入されることがあります。これらのセクタもゼロで初期化されます。</p>
<p>ここまでのまとめとして、各FATタイプにおける FATエントリの値の範囲とその意味を示します。</p>
<table class="lst" id="fat_value">
<tr><th>FAT12</th><th>FAT16</th><th>FAT32</th><th>解説</th></tr>
<tr><td><tt>0x000</tt></td><td><tt>0x0000</tt></td><td><tt>0x00000000</tt></td><td>未使用クラスタ</td></tr>
<tr><td><tt>0x001</tt></td><td><tt>0x0001</tt></td><td><tt>0x00000001</tt></td><td>予約</td></tr>
<tr><td><tt>0x002:0xFF6</tt></td><td><tt>0x0002:0xFFF6</tt></td><td><tt>0x00000002:0x0FFFFFF6</tt></td><td>使用中クラスタ (値は次のクラスタ番号)</td></tr>
<tr><td><tt>0xFF7</tt></td><td><tt>0xFFF7</tt></td><td><tt>0x0FFFFFF7</tt></td><td>不良クラスタ</td></tr>
<tr><td><tt>0xFF8:0xFFF</tt></td><td><tt>0xFFF8:0xFFFF</tt></td><td><tt>0x0FFFFFF8:0x0FFFFFFF</tt></td><td>使用中クラスタ (チェーンの終端)</td></tr>
</table>

<h3 id="fsinfo">FAT32のFSInfo構造体とバックアップ・ブート・セクタ</h3>
<p>FATのサイズは、FAT12で最大 6KB、FAT16で最大 128KBでしたが、FAT32では数MB以上に達することもよくあります。こうした理由から、空きクラスタの検索や空きクラスタ数の取得などで FAT全域をアクセスするのをなるべく避けるため、FAT32ボリュームでは FSInfo構造体がサポートされます。この構造体は<tt>BPB_FSInfo</tt>で示される FSInfoセクタに記録されます。</p>

<table class="lst4" id="tbl_fsinfo">
<caption>FAT32 FSInfoセクタ</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>FSI_LeadSig</td><td>0</td><td>4</td>
<td><tt>0x41615252</tt>。このセクタが実際に FSInfoセクタであることを示すシグネチャ1。</td>
</tr>
<tr><td>FSI_Reserved1</td><td>4</td><td>480</td>
<td>予約。フォーマット時に 0で初期化し、使用してはならない。</td>
</tr>
<tr><td>FSI_StrucSig</td><td>484</td><td>4</td>
<td><tt>0x61417272</tt>。このセクタが実際に FSInfoセクタであることを示すシグネチャ2。</td>
</tr>
<tr><td>FSI_Free_Count</td><td>488</td><td>4</td>
<td>空きクラスタ数をセットする。参考値で、必ずしも正しいとは限らない。<tt>0xFFFFFFFF</tt>の場合は実際に無効であることを示す。使用するときは少なくともそのボリュームのクラスタ数として有効かどうかチェックするべきである。</td>
</tr>
<tr><td>FSI_Nxt_Free</td><td>492</td><td>4</td>
<td>最後に割り当てられたクラスタ番号をセットする。参考値で、必ずしも正しいとは限らない。<tt>0xFFFFFFFF</tt>の場合は実際に無効であることを示す。この値は、FATドライバが新しいクラスタ・チェーンを作成するとき、空き検索を開始するクラスタ番号として使用できる。無効なときは多くは FAT[2]から検索する。</td>
</tr>
<tr><td>FSI_Reserved2</td><td>496</td><td>12</td>
<td>予約。フォーマット時に 0で初期化され、以降使用してはならない。</td>
</tr>
<tr><td>FSI_TrailSig</td><td>508</td><td>4</td>
<td><tt>0xAA550000</tt>。このセクタが実際に FSInfoセクタであることを示すシグネチャ3。</td>
</tr>
</table>
<p>これ以外の FAT32の機能として、バックアップ・ブート・レコードというものがあります。これは、FAT12/16ボリュームでは1個しか存在しかなかったブート・セクタに冗長性を持たせるための機能です。これにより、何らかの理由でブート・セクタが破損した場合の回復の可能性を高めることができます。このセクタの位置は、<tt>BPB_BkBootSec</tt>に記録されています。この値は 6が強く推奨されているので、ブート・ローダや FATドライバはブート・セクタの読み込みに失敗したとき、セクタ#6からブート・レコードの読み込みを試みるようにコーディングされています。</p>
<p>FAT32ボリュームのブート・セクタは、実際には 3つの連続したセクタがブート・セクタとされているので、ブート・セクタから連続した 3セクタが保存領域にコピーされることになります。これら 3セクタは全て 510, 511バイト目に <tt>0x55, 0xAA</tt>が記録されます。</p>

<h3 id="fat_struct">FATディレクトリ構造体</h3>
<p>ここでは長いファイル名のことは無視して、まずは基本機能である短いファイル名についてだけ解説します。FATのディレクトリの実体は特殊なアトリビュートを持ったファイルとして存在し、内容は 32バイト長のディレクトリ・エントリ構造体を格納するテーブルです。テーブル長の最大値は 65536エントリです。</p>
<p>ボリューム中唯一の特殊なディレクトリで必ず存在しなければならないのがルート・ディレクトリです。ルート・ディレクトリは、FAT12/16ボリュームでは FAT領域直後のディレクトリ領域に配置され、テーブル長も<tt>BPB_RootEntCnt</tt>に示される固定長となります。FAT32ボリュームでは静的領域ではなく、ファイルやサブ・ディレクトリと同様にデータ領域に配置されます。サブ・ディレクトリと違う点は、それを指すディレクトリ・エントリを持たないということで、ルート・ディレクトリの開始クラスタ番号は<tt>BPB_RootClus</tt>で指定されます。</p>
<p>このほかにルート・ディレクトリがサブ・ディレクトリと違う点は、サブ・ディレクトリには必ずあるドット・エントリ(<tt>".", ".."</tt>)を持たないことと、ボリューム・ラベル(<tt>ATTR_VOLUME_ID</tt>アトリビュートのセットされたエントリ)を置くことができるということです。次の表に FATボリュームのディレクトリ・エントリ構造体のフィールドを示します。</p>
<table class="lst4" id="dir_ent">
<caption>ディレクトリ・エントリ構造体</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>DIR_Name</td><td>0</td><td>11</td>
<td>短いファイル名の本体名と拡張子。</td>
</tr>
<tr><td>DIR_Attr</td><td>11</td><td>1</td>
<td>ファイル・アトリビュート。次のフラグのコンビネーションで表現される。上位2ビットは常に0でなければならない。
<tt><br>0x01: ATTR_READ_ONLY (書き込み禁止)<br>
0x02: ATTR_HIDDEN (隠し)<br>
0x04: ATTR_SYSTEM (システム)<br>
0x08: ATTR_VOLUME_ID (ボリュームラベル)<br>
0x10: ATTR_DIRECTORY (ディレクトリ)<br>
0x20: ATTR_ARCHIVE (アーカイブ)<br>
0x0F: ATTR_LONG_FILE_NAME (LFNエントリ)</tt></td>
</tr>
<tr><td>DIR_NTRes</td><td>12</td><td>1</td>
<td>短いファイル名の小文字情報を記録するフラグ(オプション)。<br>
<tt>0x08: </tt>本体名がすべて小文字。<br>
<tt>0x10: </tt>拡張子がすべて小文字。</td>
</tr>
<tr><td>DIR_CrtTimeTenth</td><td>13</td><td>1</td>
<td>DIR_CrtTimeのサブセコンド情報。<tt>DIR_CrtTime</tt>の分解能は 2秒であるが、それをさらに 200分割した値(0～199)が入る。サポートしない場合は、作成時に 0を設定し、以降変更しない。</td>
</tr>
<tr><td>DIR_CrtTime</td><td>14</td><td>2</td>
<td>このファイルが作成された時刻(オプション)。サポートしない場合は、作成時に 0を設定し、以降変更しない。</td>
</tr>
<tr><td>DIR_CrtDate</td><td>16</td><td>2</td>
<td>このファイルが作成された日付(オプション)。サポートしない場合は、作成時に 0を設定し、以降変更しない。</td>
</tr>
<tr><td>DIR_LstAccDate</td><td>18</td><td>2</td>
<td>このファイルを最後にオープンした日付(オプション)。時刻情報は無い。書き込みアクセスの場合は<tt>DIR_WrtDate</tt>と同じ値を設定すべきである。サポートしない場合は、作成時に 0を設定し、以降変更しない。</td>
</tr>
<tr><td>DIR_FstClusHI</td><td>20</td><td>2</td>
<td>このファイルの先頭クラスタ番号の上位 16ビット。FAT12/16では常に 0。</td>
</tr>
<tr><td>DIR_WrtTime</td><td>22</td><td>2</td>
<td>このファイルが最後に書き込まれた(書き込み後クローズされた)時刻。サポート必須。</td>
</tr>
<tr><td>DIR_WrtDate</td><td>24</td><td>2</td>
<td>このファイルが最後に書き込まれた日付。サポート必須。</td>
</tr>
<tr><td>DIR_FstClusLO</td><td>26</td><td>2</td>
<td>このファイルの先頭クラスタ番号の下位 16ビット。ファイル・サイズが 0のときは常に 0。</td>
</tr>
<tr><td>DIR_FileSize</td><td>28</td><td>4</td>
<td>このファイルのバイト単位のサイズ。ディレクトリの場合は常に 0。
</td>
</tr>
</table>
<p><tt>DIR_Name</tt>フィールドの先頭バイト<tt>DIR_Name[0]</tt>は、そのエントリの状態を示す重要なデータです。この値が<tt>0xE5</tt>または<tt>0x00</tt>の場合は、そのエントリは空で新たに使用可能です。それ以外の値の場合は、そのエントリは使用中です。値が<tt>0x00</tt>のときは、それ以降のエントリも全て<tt>0x00</tt>であることが保証されるので、無駄な検索を省くことができます。ファイル名の先頭バイトが<tt>0xE5</tt>になる場合は、代わりに<tt>0x05</tt>をセットします。</p>
<p><tt>DIR_Name</tt>フィールドは 11バイトの文字列で、本体と拡張子の8+3バイトの文字列として格納されます。その際、本体と拡張子を区切るピリオドは除去されます。本体 8バイト、拡張子 3バイトに満たない場合は、それぞれ残りの部分にスペース(<tt>0x20</tt>)が詰められます。文字コードには、ローカルなコード・セット(日本語の場合は CP932 Shift_JIS)が使われます。次に実際の例を示します。</p>

<pre>ファイル名         DIR_Name          解説
"FILENAME.TXT"    "FILENAMETXT"     ピリオドは除去される
"DOG.AVI"         "DOG     AVI"     8+3バイトに満たないときはスペースでパディング
"File.Txt"        "FILE    TXT"     ASCII小文字は全て大文字に置き換えられる
"file.TXT"        "FILE    TXT"     ↑に同じ
"蜃気楼.JPG"      "・気楼  JPG"      "蜃"の第一バイトが0xE5なので0x05に置き換え
"NO_EXT"          "NO_EXT     "     拡張子無し
"NO_EXT."         "NO_EXT     "     ↑に同じ
".cnf"                              ※本体無しは不可
"new file.txt"                      ※スペースは使用不可
"file[1].c++"                       ※[]や+はダメ文字
"longext.jpeg"                      ※8+3形式に入らないのはダメ
"arch.tar.gz"                       ※8+3形式に入らないのはダメ</pre>

<p>
ファイル名に使用可能な文字は、ASCIIコードの<br>
<em><tt>0～9 A～Z ! # $ % &amp; ' ( ) - @ ^ _ ` { } ~</tt></em><br>
と、拡張文字コード(0x80～0xFF)です。ASCII小文字 a～z は使用できませんが、与えられた場合はエラーとせず、大文字に置き換られて記録・検索されます。拡張文字の小文字も ä→Ä のように大文字変換されますが、そのコード・ページに対応する大文字が存在しない場合は、ê→E のように変換されます。このように拡張文字の大文字変換はコード・ページ間で異なるので、異なるコード・ページ間での互換性が低下します。日本語環境での拡張文字の扱いについては、この先の「システム間の互換性」を参照してください。</p>
<p>ある一つのディレクトリの中では、全てのファイル名がユニークです。そのエントリの中には<tt>DIR_Name</tt>に同じ文字列を含むエントリは 2つ以上存在することはありません。<tt>DIR_Attr</tt>フィールドは、次の表に示すようにそのファイルの属性を示します。</p>
<table class="lst4" id="attribute">
<caption>ファイル属性</caption>
<tr><th>フラグ</th><th>解説</th></tr>
<tr><td>ATTR_READ_ONLY</td><td>書き込み禁止。このファイルへの書き込みや消去は、拒否されるべきである。</td></tr>
<tr><td>ATTR_HIDDEN</td><td>通常のディレクトリ表示でこのファイルを表示しない。(OS依存)</td></tr>
<tr><td>ATTR_SYSTEM</td><td>システム関連の重要ファイルであることを示す。(OS依存)</td></tr>
<tr><td>ATTR_VOLUME_ID</td><td>この属性を持つエントリは、ルート・ディレクトリに 1個だけ存在できる。このエントリの持つ名前は、そのボリュームのラベル名である。このエントリはデータを持たず、<tt>DIR_FstClusHI</tt>、<tt>DIR_FstClusLO</tt>および<tt>DIR_FileSize</tt>は常に 0でなければならない。</td></tr>
<tr><td>ATTR_DIRECTORY</td><td>このファイルはサブ・ディレクトリのコンテナである。以下で解説。</td></tr>
<tr><td>ATTR_ARCHIVE</td><td>ディレクトリ・エントリへの何らかの書き込みが発生したとき FATドライバによってセットされる。バックアップ・ツールが変更されたファイルを見つけるために使用し、バックアップ後にクリアする。現在はあまり使われていない。</td></tr>
<tr><td>ATTR_LONG_NAME</td><td>このフラグの組み合わせは、そのエントリが長いファイル名の一部であることを示す。これについては後ろのセクションで解説。</td></tr>
</table>

<h3 id="fat_dir">ディレクトリの操作</h3>
<h4>ファイルの作成</h4>
<p>ファイルを作成するときは、ディレクトリ・テーブルの空きを探してその名前のエントリを作成します。テーブルがクラスタの最後まで埋まっているときは、新たなクラスタを割り当ててチェーンを延ばします。ただし、エントリ数は 65536を越えることはできません。静的ディレクトリ・テーブル(FAT12/16のルート・ディレクトリ)の場合は、テーブルが満杯になったらそれ以上のエントリは作成できません。エントリの<tt>DIR_Attr</tt>フィールドには<tt>ATTR_ARCHIVE</tt>フラグを設定し、<tt>DIR_FstClusHI, DIR_FstClusLO, DIR_FileSize</tt>は 0が初期値となります。ファイルにデータが書き込まれ、ファイル・サイズが 0→1以上に変化するとき新しいクラスタが割り当てられ、<tt>DIR_FstClusHI, DIR_FstClusLO</tt>にそのクラスタ番号がセットされます。以降、ファイル・サイズが増大してクラスタがあふれるたびに新しいクラスタが割り当てられ、クラスタ・チェーンが延びていきます。</p>
<h4>ディレクトリの作成</h4>
<p>サブ・ディレクトリを作成するときは、その名前のエントリを作成し、<tt>DIR_Attr</tt>フィールドに<tt>ATTR_DIRECTORY</tt>フラグと<tt>ATTR_ARCHIVE</tt>フラグを設定します。ディレクトリとして特別なことは、その内容がディレクトリ・エントリのテーブルであることだけで、それ以外はファイルに似ています。ディレクトリはサイズ情報を持たず<tt>DIR_FileSize</tt>には常に 0を設定しなければなりません。ディレクトリには最初にクラスタを 1個割り当て、先頭クラスタ番号のフィールド<tt>DIR_FstClusHI, DIR_FstClusLO</tt>には、割り当てたクラスタ番号をセットします。割り当てられたクラスタは、全体を 0で初期化(全て未使用状態)します。</p>
<p>サブ・ディレクトリのテーブル先頭の 2エントリには、必ずドット・エントリ(<tt>".", ".."</tt>)を作成します。ドット・エントリは、ルート・ディレクトリには存在せず、サブ・ディレクトリにだけ存在します。<tt>DIR[0]</tt>の<tt>DIR_Name</tt>には、<tt>".&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</tt>を、<tt>DIR[1]</tt>には<tt>"..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</tt>をセットします。これらは<tt>ATTR_DIRECTORY</tt>属性を持つエントリですが、それ自身はテーブルは持たずに、他のエントリが持つテーブルを指すだけのエントリになっています。<tt>"."</tt>エントリの先頭クラスタ番号のフィールドには、それが置かれているディレクトリ自身(つまり今作成した)の開始クラスタ番号を指します。<tt>".."</tt>エントリは、親ディレクトリ(このディレクトリのエントリが置かれたディレクトリ)の開始クラスタ番号を指します。親ディレクトリがルート・ディレクトリの場合は、0をセットします(たとえ FAT32の場合でも)。</p>
<h4>ファイルの削除</h4>
<p>ファイルを削除するときは<tt>DIR_Name[0]</tt>に<tt>0xE5</tt>をセットしてディレクトリ・エントリを解放します。ファイルがクラスタを持っている場合、チェーンを辿って全て解放(FATエントリに0をセット)します。</p>
<h4>ディレクトリの削除</h4>
<p>サブ・ディレクトリの削除はファイルと同じですが、テーブルが空(ドット・エントリ以外に何も無い状態)でないときは削除することはできません。</p>

<h3 id="time_fmt">日付・時刻フィールドのフォーマット</h3>
<p>ディレクトリ・エントリには、時間に関するフィールドがいくつかあります。多くの FATドライバはサポート必須フィールドである<tt>DIR_WrtTime, DIR_WrtDate</tt>のみサポートし、ほかのオプション・フィールドはサポートしません。サポートしないフィールドはエントリ作成時に 0で初期化し、以降変更するべきではありません。日付と時刻のフィールドは次のようなフォーマットになっています。時刻は全てローカル時間です。</p>
<table class="lst4" id="tbl_time">
<tr><th>フィールド</th><th>ビット割り当て</th></tr>
<tr><td>DIR_WrtDate<br>DIR_CrtDate<br>DIR_LstAccDate</td><td>Bit 15～9: 1980年から起算した年(0～127)。1980～2107年。<br>Bit 8～5: 月 (1～12)。<br>Bit 4～0: 日 (1～31)。</td></tr>
<tr><td>DIR_WrtTime<br>DIR_CrtTime</td><td>Bit 15～11: 時 (0～23)。<br>Bit 10～5: 分 (0～59)。<br>Bit 4～0: 秒を 2で割った値 (0～29)。0～58秒。</td></tr>
</table>

<h3 id="lfn">長いファイル名</h3>
<p>FATファイル・システムに長いファイル名(<em>LFN</em>)を付加するには、既存のシステムでの下位互換性を保ったまま拡張する必要があります。具体的には次に示すようなことが要求されます。</p>
<ul>
<li>本質的に既存のシステムにおいて長いファイル名の存在が認識されないようにします。その第一の目標は、MS-DOSや古いWindowsのファイルAPIで容易に発見されないことです。長いファイル名を発見できるのは、全ファイル名にマッチのワイルド・カード(<tt>*.*</tt>)で全アトリビュート・マッチングで検索した場合と、殆ど使われていない FCBベースの APIだけとします。</li>
<li>長いファイル名は、そのファイルの(既存の短いファイル名(<em>SFN</em>)の)ディレクトリ・エントリに物理的に近い場所に配置します。つまり、そのファイルの SFNエントリに隣接して配置し、その存在はパフォーマンスに大きな影響を与えないようにします。</li>
<li>もしディスク・ユーティリティに LFNエントリが発見されても、ファイル・システムの健全性に悪影響を与えられることのないようにします。ディスク・ユーティリティは一般的にファイルAPIを使わず、それ自身でセクタを読み書きして FATファイル・システムを解析・操作します。LFN以前のディスク・ユーティリティでは、LFNエントリは未知の存在(つまりはディレクトリ・エントリの破損)と認識され、何らかの修復の対象となります。このような事態でもデータの損失に至らないようにする必要があります。</li>
</ul>
<p>これらの条件を満たすため、LFNは特殊なアトリビュートを持ったディレクトリ・エントリとして定義されています。前のセクションで既に説明していますが、LFNを構成するエントリとしてのアトリビュート(<tt>ATTR_LONG_NAME</tt>)は、既存のアトリビュートの組み合わせ(<tt>ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID</tt>)として表現されます。また、あるエントリが LFNの一部であるかどうかを調べるためのマスク値(<tt>ATTR_LONG_NAME_MASK</tt>)は、<tt>ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID | ATTR_DIRECTORY | ATTR_ARCHIVE</tt>として定義されています。この値で<tt>DIR_Attr</tt>をANDマスクし、<tt>ATTR_LONG_NAME</tt>に一致したら、そのエントリは LFNエントリの一部です。このようなディレクトリ・エントリを見つけたときは、次に示すように SFNエントリとは異なるフィールドとして解釈します</p>

<table class="lst4" id="lfn_entry">
<caption>LFNを構成するディレクトリ・エントリ構造体</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>LDIR_Ord</td><td>0</td><td>1</td>
<td>このディレクトリ・エントリが LFNエントリ(1個のLFNを構成するディレクトリ・エントリ群)のどの部分かを示すシーケンス番号(1～20)。1が LFNの先頭部を意味する。<tt>LAST_LONG_ENTRY</tt>フラグ(<tt>0x40</tt>)が立っているときは、シーケンスの最後尾の部分であることを示す。</td>
</tr>
<tr><td>LDIR_Name1</td><td>1</td><td>10</td>
<td>名前。1文字目～5文字目。</td>
<tr><td>LDIR_Attr</td><td>11</td><td>1</td>
<td>LFNアトリビュート。このエントリが LFNエントリの一部であることを示すため、<tt>ATTR_LONG_NAME</tt>でなければならない。</td>
<tr><td>LDIR_Type</td><td>12</td><td>1</td>
<td>LFNのタイプ。常に0でなければならず、0以外は予約。</td>
<tr><td>LDIR_Chksum</td><td>13</td><td>1</td>
<td>この LFNエントリと結びつけられている SFNエントリのチェックサム。</td>
<tr><td>LDIR_Name2</td><td>14</td><td>12</td>
<td>名前。6文字目～11文字目。</td>
<tr><td>LDIR_FstClusLO</td><td>26</td><td>2</td>
<td>古いディスク・ユーティリティによる危険の可能性を避けるため、0がセットされる。</td>
<tr><td>LDIR_Name3</td><td>28</td><td>4</td>
<td>名前。12文字目～13文字目。</td>
</tr>
</table>
<p>LFNエントリは常に対応する SFNエントリに関連づけられていて、単独で存在することはありません。ファイルは SFNのみ、または SFNと LFNの 2つの名前を持つということです。これは、LFN非対応システムでの下位互換性を保つためです。LFNがある場合はそれがファイルの主たる名前となります。LFN非対応システムは LFNエントリを認識できませんが、SFNでそのファイルをアクセスできます。LFN対応システムの場合、LFNと SFNのどちらでもファイル・アクセスできます。LFNエントリは長いファイル名の文字列情報だけしか持たず、それ以外のファイル情報(サイズ・日付・開始クラスタ等)は、SFNエントリの中のものが使用されます。もしも SFNエントリとの関連づけの切れた LFNエントリが存在した場合、もはやその LFNエントリは無効です。次の図に LFNエントリ(3個のエントリを占有する)と SFNエントリのセットがディレクトリ・テーブルに格納される様子を示します。</p>
<table class="lst" id="lfn_tbl">
<caption>"MultiMediaCard System Summary.pdf" の格納</caption>
<tr><th>格納位置</th><th>先頭バイト</th><th>名前フィールド</th><th>アトリビュート</th><th>内容</th></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DIR[N-3]</td><td>0x43</td><td>ary.pdf</td><td>--VSHR</td><td>LFN3番目(lfn[26..38])</td></tr>
<tr><td>DIR[N-2]</td><td>0x02</td><td>d System Summ</td><td>--VSHR</td><td>LFN2番目(lfn[13..25])</td></tr>
<tr><td>DIR[N-1]</td><td>0x01</td><td>MultiMediaCar</td><td>--VSHR</td><td>LFN1番目(lfn[0..12])</td></tr>
<tr><td>DIR[N]</td><td>'M'</td><td>MULTIM~1PDF</td><td>A-----</td><td>SFNエントリ</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>
<p>LFNは、それを構成するエントリ 1個あたり 13文字で格納され、複数のエントリを占有します。LFNの最大文字数は 255文字なので、最大 20エントリを占有することになります。たとえば、例に示す 33文字の LFNエントリの場合は、<tt>LDIR_Ord</tt>に<tt>0x01, 0x02, 0x43</tt>を持つ 3つのディレクトリ・エントリで構成されます。LFNエントリのファイル名は Unicode (UCS-2)で格納され、1文字あたり 16ビットとなります。文字数が 13の倍数に一致しない場合、名前はヌル文字(<tt>0x0000</tt>)で終端され、その後ろは<tt>0xFFFF</tt>でパディングします。SFNエントリの名前は、与えられたファイル名から自動生成されます(アルゴリズムは後述)。</p>
<p>LFNエントリは関連づけられた SFNエントリの直前に降順で配置されます。<tt>LDIR_Ord</tt>の値は 1から連続していなければならず、これらのグループは連続したエントリに配置されます。これらの条件が一つでも満たされない場合、その LFNエントリは無効になります。</p>
<p>さらにチェック・サムを使って LFNエントリと SFNエントリの関連性が確認されます。LFNエントリを構成するエントリには、関連づけられている SFNエントリのチェック・サムがそれぞれの<tt>LDIR_Chksum</tt>に記録されます。チェック・サムの値は、次のアルゴリズムで SFNエントリの<tt>DIR_Name</tt>フィールドから生成されます。</p>
<pre>
U8 create_sum (const DIR* entry)
{
    int i;
    U8 sum;

    for (i = sum = 0; i &lt; 11; i++)
        sum = (sum &gt;&gt; 1) + (sum &lt;&lt; 7) + entry-&gt;DIR_Name[i];

    return sum;
}
</pre>
<p>チェック・サムが一つでも一致しない場合は、その LFNエントリは無効になります。これは LFN非対応システムがディレクトリ・テーブルを操作(削除・作成・名前の変更など)した結果、不正な関連づけになるのを防ぐためです。しかし、無効になった LFNエントリはゴミになってテーブルを占有し続けるので、そのような状態が繰り返し発生するとボリュームの利用効率がどんどん悪化していきます。特にテーブル長の限られる FAT12/16のルート・ディレクトリでは切実な問題です。無効になった LFNエントリはディスク・ユーティリティ等で発見・除去されます。</p>
<h3 id="name_space">名前の範囲とコード・ページ</h3>
<h4>短いファイル名</h4>
<p>短いファイル名では、8バイトまでの本体名とオプションのピリオド(.) + 3バイトまでの拡張子に制限される、いわゆる 8.3形式のファイル名が使用できます。パス名のトータル長は、64バイトのパス + 12バイトのファイル名 + 3バイトのドライブ文字の合計 79バイトとなります(終端のNUL文字を含まず)。ファイル名を構成する文字は、ASCII英数と拡張文字(0x80～0xFF)および一部の ASCII記号<em>$ % ' - _ @ ~ ` ! ( ) { } ^ # &amp;</em>の任意の組み合わせが可能です。</p>
<p>短いファイル名は、SFNエントリにそのシステムの OEMコード・ページ(MS-DOSや古い Windowsで使用される)で格納されます。SFNエントリでは ASCII英小文字が使用禁止なので、ファイル名に含まれる小文字は、必ず大文字に変換されて SFNエントリに格納されます。このため、SFNでは大文字小文字情報は失われます。</p>
<h4>長いファイル名</h4>
<p>長いファイル名では、255文字までのファイル名が使用可能で、パス名のトータル長は 259文字までです(共に終端のNUL文字を含まず)。使用可能な文字は、SFNでサポートされる文字全てに加え、ASCII文字の<em>+ , ; = [ ]</em>(SFNでは使用禁止)が加わっています。ピリオドはファイル名中にいくつでも含めることができ、またスペースもファイル名の中に挿入することができます。ただし、ファイル名の末尾に来るピリオドやスペースは無効で、全て無視・除去されます。ファイル名の先頭に来るピリオドやスペースは有効です。</p>
<p>LFNエントリには、先頭のピリオドの除去や大文字変換は行わずに<em>そのままの形</em>で格納されます。文字コードは Unicode (UCS-2)です。</p>
<p>このように SFNエントリと LFNエントリで異なる文字コードが使われるため、一般的なインプリメントではそれらのコードの相互変換が必要になります。コード・ページが SBCSの場合は特に問題にはなりませんが、漢字圏では変換テーブルのサイズが数十～数百Kバイトに膨れあがります。これはメモリの乏しい小規模な組み込みシステムでは重大な問題といえます。</p>

<h3 id="name_matching">LFNとSFNのマッチング</h3>
<p>まず、SFNエントリに記録されるファイル名の形式を SFN形式、LFNエントリに記録されるファイル名の形式を LFN形式とします。それらは一つの名前から同時に生成されます。あるディレクトリ中のファイル名は、SFN/LFNに関わらず異なるファイルで同じものは二つとありません。LFNエントリには小文字もまた保持されますが、大小文字はマッチングの際に無視されます。したがって、<tt>"foobar", "FOOBAR", "FooBar"</tt>は同じ名前と見なされます。このように、全てのタイプのファイル検索動作において ASCII大小文字は無視されます。</p>
<p>LFNエントリのファイル名を読み出すとき、文字コードが OEM－Unicode変換できない場合、ファイル・システムはそれらをアンダースコア<tt>'_'</tt>に変換します。ディスク上の値を変更することはありません。</p>

<h3 id="name_conversion">SFNの生成と添字の付加</h3>
<p>LFN対応システムでは、ファイル・システムAPIに渡されたファイル名は常に LFNとして扱うこととします。<em>SFNは常に自動生成</em>される必要があり、LFNと SFNについてそれぞれ個別に指定することを許可してはなりません。これらの条件は、各システムのユーザやアプリケーション間での名前に関わる混乱の防止、一つのファイルが持つ名前の統一性の確保、名前の衝突の防止などの目的から来るものです。自動生成される SFNは、<em>本体名(+添字)(+拡張子)</em>で構成されます。SFNは次の手順で生成されます。</p>
<ol>
<li>名前末尾のスペース<tt>(0x20)</tt>やピリオド<tt>(0x2E)</tt>は除去済みとする(ファイル名の条件)。</li>
<li>スペースが含まれるときは全て取り除き、損失変換フラグを立てる。</li>
<li>先頭にピリオドがあるときは全て取り除き、損失変換フラグを立てる。</li>
<li>ピリオドが 2個以上あるときは最後を残して取り除き、損失変換フラグを立てる。</li>
<li>小文字は拡張文字を含めて全て大文字に変換する。</li>
<li>入力がUnicodeの場合は、OEMコードに変換する。また、OEMコードに無い文字や SFNで使用できない文字は、アンダースコア '_' に置き換え、損失変換フラグを立てる。</li>
<li>SFN出力バッファ(8+3バイト)をスペース<tt>(0x20)</tt>で埋める。</li>
<li>SFN本体の生成。LFN先頭から SFN本体部へ 1文字ずつコピーする。終了条件は、(LFN終端に到達 || ピリオドを発見 || 8バイトに達した)。8バイトを越える長さがあったときは、損失変換フラグを立てる。</li>
<li>SFN拡張子の生成。ピリオドが存在するときは、その次の文字から SFNの拡張子部へ 1文字つづコピーする。終了条件は、(LFN終端に到達 || 3バイトに達した)。3バイトを超える長さがあったときは、損失変換フラグを立てる。</li>
</ol>
<p>これで<em>本体名(+拡張子)</em>のフォーマットで SFNが完成します。損失変換フラグが立っている(つまり LFNが 8.3形式に適合しない)場合は、続いて本体名に<em>添字</em>を付加します。添字のフォーマットは、1文字のチルダと数字の組み合わせ<em>~n</em>(nは1～6桁の値)です。</p>
<p>このようにして生成された名前がそのディレクトリ内の既存のエントリと衝突する場合は、nの値を変えて衝突しない名前を探します。通常は nを 1から順に増やしながらユニークな名前を検索しますが、そのアルゴリズムはインプリメント依存です。たとえば、Windowsでは 1から順に検索して 5回衝突した場合は、何かのハッシュ値を使用しています。添字で本体名が 8バイトを越えてしまう場合は、本体名を末尾から削って 8バイトに収まるようにします。</p>

<h3 id="lfn_elimination">LFNエントリの抑止</h3>
<p>名前が 8.3形式に適合する場合は、LFNと SFNは必ず同じ名前(大文字に変換されることを除き)になります。さらに、名前が次の条件を満たす場合は、LFNエントリは生成されません。</p>
<ul>
<li>8.3形式に適合し、</li>
<li>ASCII小文字を含まず、</li>
<li>拡張文字(0x80以上)を含まない。</li>
</ul>
<p>NT系Windowsでは次の条件のときにも LFNエントリが抑止されます。</p>
<ul>
<li>8.3形式に適合し、</li>
<li>本体部、拡張子部のどちらかまたは両方がその中に ASCII小文字を含み、</li>
<li>本体部、拡張子部どちらにおいてもその中で ASCII大小文字が混在せず、</li>
<li>拡張文字(0x80以上)を含まない。</li>
</ul>
<p>この場合、小文字情報が SFNエントリの<tt>DIR_NTRes</tt>フィールドに書き込まれ、LFNエントリは抑止されます。この条件を満たすファイル名は、<tt>"lower12.dll", "system32", "FDCMD.exe"</tt>などごく一般的なもので、NT系Windowsではシステム・ファイルとしても大量に存在する形式の名前です。これにより、ディレクトリ・テーブルの肥大化を抑えています。<tt>DIR_NTRes</tt>フィールドをサポートしない LFNシステム(例えばWindows9X)ではこれらは通常の SFNエントリとして認識され、全て大文字として見えることになります。FATファイル・システムでは名前のマッチングにおいて大文字小文字の区別はないので、小文字が大文字に化けてもシステム上は問題にはなりませんが、一部のUnix系アプリケーションは問題を起こすことがあります。</p>

<h3 id="lfn_comp">システム間の互換性</h3>
<h4>LFN非対応システム</h4>
<p>LFNのサポートは固定ディスク・ドライブにおいて最も必要とされますが、リムーバブル・ディスクにおいてもまたサポートされます。リムーバブル・ディスクは複数のシステム間で使用されるため、下位互換性は特に重要なことです。LFN機能は LFN非対応システムでの互換性を損なうことなく実装されています。たとえば、LFNの使われているボリュームは、LFN非対応システムでアクセスすることができます。また、LFNは既存のボリュームの変換処理することなしに使用することができます。既存のファイルに変更が加えられることはありません。LFNエントリは、ディレクトリ・エントリを作成するとき(新規作成や名前の変更)に作成されます。LFN名を持たないファイルに LFN名を付けるときは、エントリの配置の関係上 SFNエントリは移動されます。LFNエントリは非対応システムに対しては隠しファイルと同じ程度に隠蔽されていて、通常の使い方では問題を起こすことはありません。</p>
<p>LFN非対応システムでは LFNエントリの存在には一切関知しないので、ディレクトリ操作によっては LFNエントリが破壊されることがあります。この場合もファイル・データが失われることはありません。たとえば、LFNを持つファイルの名前が変更された場合、サムの不一致となり LFNエントリと SFNエントリの関連が解かれてそのファイルの LFNが失われます。また、ボリューム・ラベルを削除・変更した場合、どこかの LFNエントリが破壊され、いずれかのファイルの LFNが失われる可能性があります。この場合もそのファイルのデータへのダメージはありません。</p>
<h4>日本語の大文字変換</h4>
<p>SFNエントリの大文字変換規則は拡張文字に対しても適用されますが、日本語MS-DOSでは拡張文字(全角英字・ギリシャ文字・キリル文字)の小文字は変換されずに記録されていました。NT系Windowsからはこれらの拡張文字に対しても大文字変換されるようになっています。しかし、これにより深刻な互換性問題が起きています。たとえば、日本語MS-DOSで<tt>"Ｆａｓｔ.TXT"</tt>というファイルを作成し、そのボリュームを Windows XPでマウントした場合、そのファイルはもはや開くことができません。NT系Windowsでは、そのファイル名に対して<tt>"ＦＡＳＴ.TXT"</tt>で SFNエントリを探すためマッチせず見つけられないからです。対策としては、このようなファイル名の使用を避けるしかありません。9X系Windosも SFN拡張文字の大文字変換をしませんが、LFNエントリも作成されるので NT系Windowsからアクセス可能です。</p>
<h4>異なる OEMコード・ページ</h4>
<p>いくつかの OEMコード・ページは、DBCSが採用されます。日本語環境の場合は Shift_JISを使用することになっています。DBCSでは 2バイト文字の 2バイト目のコードが使用禁止文字と一致することがあります。これは、SBCSシステムで DBCSファイル名を扱おうとしたとき問題が発生します。同様に大文字変換の関係上、SBCS拡張文字を含む名前のファイルは異なるコード・ページのシステムで正常に開くことができません。異なる OEMコード・ページのシステム間で相互利用する場合は、ファイル名に拡張文字の使用を避ける必要があります。</p>
<p>長いファイル名についてはUnicodeで記録されるため、コード・ページの問題はありません。しかし、API上の扱いがOEMコードの場合はLFN不完全対応となり、同様の問題が発生します。</p>
<h4>Mac OS X</h4>
<p>Mac OS Xのファイル・システムではピリオドやスペースで終わるファイル名が使用可能です。Mac OS Xも FATボリュームへのアクセスが可能ですが、このようなファイル名は FATファイル・システムは許可していません。作成するファイル名がこれらの文字で終わる場合、Mac OS Xはそれらを特殊文字に置換(スペース→U+F028、ピリオド→U+F029 )した名前でファイルを作成します。Mac OS XとFATボリューム経由でファイル交換する場合はこの点を考慮する必要があります。当然ですが、これらのファイルをLFNで開くにはAPIレベルでUnicodeに対応していなければなりません。</p>

<h3 id="partition">ストレージ(物理ドライブ)の区画分け</h3>
<p>ストレージの区画分けに関しては FATファイル・システムのスコープを外れますが、組み込みシステムへのインプリメントの際に必要となるので、ここで簡単に解説しておきます。</p>
<p>固定ディスク・ドライブはいくつかの区画(パーテーション)に分割して使用されることがよくあります。たとえば、8Gバイトの固定ディスク・ドライブを 3つの区画に分けて、4G、2G、2Gバイトのボリュームを作成するなどといった使い方です。多くの場合は、区画は 1個だけ設けられ 1台の物理ドライブに 1個のボリュームで使用されます。</p>
<p>区画分けのルールには FDISK形式と SFD(Super Floppy Disk)形式の2 つの種類があります。前者は物理ドライブの先頭物理セクタ(Master Boot Record)に<em>区画テーブル</em>が置かれていて、そのドライブがどのように分割されているかが記録されます。後者は名前が示すようにフロッピー・ディスクの延長で、単に区画分けのされていない形式です。ボリュームは物理ドライブの先頭物理セクタから始まります。</p>
<p>FDISK形式は固定ディスク・ドライブで常に使用されるほか、一部のリムーバブル・ストレージ(SDカード, CFカード, USBメモリ)でも標準的に使用されます。SFD形式は、それ以外のリムーバブル・ストレージ(フロッピーディスク、光磁気ディスク、MicroDriveなど)で標準的に使用されます。次の表にMBRのフィールドを示します。</p>
<table class="lst4" id="mbr_fmt">
<caption>MBR(物理セクタ0)のフィールド</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>MBR_bootcode</td><td>0</td><td>446</td>
<td>起動コード。システム依存。使用しないときは 0で埋められる。</td>
</tr>
<tr><td>MBR_Partation1</td><td>446</td><td>16</td>
<td>区画テーブル・エントリ1。区画のステータスと範囲を示す。フィールドについては後述。</td>
</tr>
<tr><td>MBR_Partation2</td><td>462</td><td>16</td>
<td>区画テーブル・エントリ2。</td>
</tr>
<tr><td>MBR_Partation3</td><td>478</td><td>16</td>
<td>区画テーブル・エントリ3。</td>
</tr>
<tr><td>MBR_Partation4</td><td>494</td><td>16</td>
<td>区画テーブル・エントリ4。</td>
</tr>
<tr><td>MBR_Sig</td><td>510</td><td>2</td>
<td><tt>0x55, 0xAA</tt>。MBRが有効であることを示す。この値が確認できないときは、MBRは無効である。</td>
</tr>
</table>
<p>区画テーブル・エントリのフィールドは次のようになっていて、このエントリが MBRに最大 4個格納できます。これは、一つのドライブを最大 4分割できるということです。拡張区画といってその中をさらに多くの区画に分けることもできますが、ここでは割愛します。</p>
<table class="lst4" id="mbr_ent_fmt">
<caption>区画テーブル・エントリのフィールド</caption>
<tr><th>名前</th><th>Offset</th><th>Size</th><th>解説</th></tr>
<tr><td>PT_BootID</td><td>0</td><td>1</td>
<td>ブート標識。<br>
0x00:ブート不可<br>
0x80:ブート可<br>
ブート可はこの区画から起動できることを示すが、実際にはシステム依存。ブート可に設定できるのは、いずれか一つの区画だけである。</td>
</tr>
<tr><td>PT_StartHd</td><td>1</td><td>1</td>
<td>CHS形式で区画の開始物理セクタを示すヘッド番号(<tt>0～254</tt>)。</td>
</tr>
<tr><td>PT_StartCySc</td><td>2</td><td>2</td>
<td>CHS形式で区画の開始物理セクタを示すシリンダ番号(下位10ビット:<tt>0～1023</tt>)とトラック内セクタ番号(上位6ビット:<tt>1～63</tt>)。</td>
</tr>
<tr><td>PT_System</td><td>4</td><td>1</td>
<td>この区画の種類(代表的なもの)。<br>
0x00: 無し(空きエントリ)<br>
0x01: FAT12 (CHS/LBA)<br>
0x04: FAT16 (65536セクタ未満 CHS/LBA)<br>
0x05: 拡張区画 (CHS/LBA)<br>
0x06: FAT12/16 (65536セクタ以上 CHS/LBA)<br>
0x07: NTFS (CHS/LBA)<br>
0x0B: FAT32 (CHS/LBA)<br>
0x0C: FAT32 (LBA)<br>
0x0E: FAT12/16 (LBA)<br>
0x0F: 拡張区画 (LBA)<br>
</td>
</tr>
<tr><td>PT_EndHd</td><td>1</td><td>1</td>
<td>CHS形式で区画の終了物理セクタを示すヘッド番号(<tt>0～254</tt>)。</td>
</tr>
<tr><td>PT_EndCySc</td><td>2</td><td>2</td>
<td>CHS形式で区画の終了物理セクタを示すシリンダ番号(下位10ビット:<tt>0～1023</tt>)とトラック内セクタ番号(上位6ビット:<tt>1～63</tt>)。</td>
</tr>
<tr><td>PT_LbaOfs</td><td>8</td><td>4</td>
<td>LBA形式で区画の開始物理セクタ番号を示す(<tt>1～0xFFFFFFFF</tt>)。</td>
</tr>
<tr><td>PT_LbaSize</td><td>12</td><td>4</td>
<td>LBA形式で区画のサイズを示す(<tt>1～0xFFFFFFFF</tt>)。</td>
</tr>
</table>
<p>区画テーブルは常に全てのエントリが使われるわけではありません。通常は区画が 1個だけ作成され、ほかのエントリは空になっています。それぞれのエントリは、物理ドライブ上で互いに重複しない任意の区画を指しています。そして、それぞれの区画の先頭セクタがボリュームの開始セクタになります。</p>
<p>区画の範囲の表現には CHS形式と LBA形式の 2通りがあり、それぞれで記録されています。CHS形式はドライブがジオメトリを持つときに使用されますが実際はシステム依存です。LBAでのアクセスが可能なドライブの場合は、LBA形式のフィールド(区画先頭物理セクタ番号とセクタ数)を使用します。区画が CHSで表現可能な範囲を超えた部分(8Gバイト以降)にかかる場合は CHSフィールドは無効です。</p>

<p class="foot"><img src="../p/sign.png" alt=""></p>
</body>
</html>
